package = libcrt
headers = aws/common/allocator.h \
        aws/common/common.h \
        aws/common/error.h \
        aws/common/byte_buf.h \
        aws/common/string.h \
        aws/common/logging.h \
        aws/common/date_time.h \
        aws/io/io.h \
        aws/io/event_loop.h \
        aws/io/host_resolver.h \
        aws/io/stream.h \
        aws/io/channel_bootstrap.h \
        aws/io/tls_channel_handler.h \
        aws/io/socket.h \
        aws/io/uri.h \
        aws/http/http.h \
        aws/http/connection.h \
        aws/http/connection_manager.h \
        aws/http/request_response.h \
        aws/http/proxy.h \
        aws/compression/compression.h \
        aws/auth/credentials.h \
        aws/auth/signing.h \
        aws/auth/signing_config.h \
        aws/auth/signable.h \
        aws/auth/signing_result.h \
        aws/compression/compression.h \
        aws/cal/hash.h \
        aws/cal/cal.h \
        aws/checksums/crc.h
headerFilter = aws/common/* aws/io/* aws/http/* aws/compression/* aws/auth/* aws/checksums/* aws/cal/*

linkerOpts.osx = -framework Security -framework Network
linkerOpts.ios = -framework Security -framework Network
linkerOpts.mingw = -lcrypt32 -lsecur32 -lncrypt -lshlwapi

# included libs are linked automatically, adding linkerOpts like `-laws-c-common` causes
# issues downstream as it will search for that library still.
staticLibraries = libaws-crt-kotlin.a

---

// prototypes
static void s_crt_kotlin_init_allocator(int trace_level);
static void s_crt_kotlin_clean_up(void);
static void s_crt_kotlin_logger_cleanup(void);
static void s_crt_kotlin_log(enum aws_log_level level, aws_log_subject_t subject, const char *message);

// definitions
static struct aws_allocator *s_crt_kotlin_allocator = NULL;
int g_memtrace_level = 0;

#define AWS_CRT_KOTLIN_PACKAGE_ID 16

enum aws_kotlin_crt_log_subject {
    AWS_LS_KOTLIN_CRT_GENERAL = AWS_LOG_SUBJECT_BEGIN_RANGE(AWS_CRT_KOTLIN_PACKAGE_ID),
    AWS_LS_KOTLIN_CRT_LAST = AWS_LOG_SUBJECT_END_RANGE(AWS_CRT_KOTLIN_PACKAGE_ID)
};

static struct aws_log_subject_info s_crt_log_subject_infos[] = {
    DEFINE_LOG_SUBJECT_INFO(
        AWS_LS_KOTLIN_CRT_GENERAL, "kotlin-crt-general", "Subject for aws-crt-kotlin logging that defies categorization"),
};

static struct aws_log_subject_info_list s_crt_log_subject_list = {
    .subject_list = s_crt_log_subject_infos,
    .count = AWS_ARRAY_SIZE(s_crt_log_subject_infos),
};


static void s_crt_kotlin_init_allocator(int trace_level) {
    if (trace_level > 0) {
        g_memtrace_level = trace_level;
        struct aws_allocator *allocator = aws_default_allocator();
        allocator = aws_mem_tracer_new(allocator, NULL, (enum aws_mem_trace_level)trace_level, 8);
        s_crt_kotlin_allocator = allocator;
    } else {
        s_crt_kotlin_allocator = aws_default_allocator();
    }
}

/**
 * Cleans up allocator and logging. This should be the absolute last thing called after cleaning up all the other
 * initialized CRT* libs.
 */
static void s_crt_kotlin_clean_up(void) {
    if (g_memtrace_level) {
        aws_mem_tracer_dump(s_crt_kotlin_allocator);
    }

    s_crt_kotlin_logger_cleanup();

    if (g_memtrace_level) {
        aws_mem_tracer_destroy(s_crt_kotlin_allocator);
    }
}


/**
 * Obtaining static variables is difficult in kn, this gives us a stable variable to wire up that works
 * with the kn memory model
 */
static struct aws_logger s_crt_kotlin_logger;


/**
 * macros not available through generated kn bridge
 */
static void s_crt_kotlin_log(enum aws_log_level level, aws_log_subject_t subject, const char *message) {
    AWS_LOGF(level, subject, "%s", message);
}

/**
 * Cleanup runs after kn runtime has been torn down, we need to do this outside of kotlin's world
 */
static void s_crt_kotlin_logger_cleanup(void) {
    if (aws_logger_get() == &s_crt_kotlin_logger) {
        aws_logger_set(NULL);
        aws_logger_clean_up(&s_crt_kotlin_logger);
    }
}
